\n# Liquidation Mechanics\n\n## Overview\n\nLiquidations are critical for maintaining protocol solvency. When a borrower's position becomes undercollateralized, liquidators can repay part or all of the debt in exchange for the collateral plus a bonus.\n\n## Health Factor\n\nThe health factor determines when a position can be liquidated:\n\n```\nHealth Factor = (Collateral Value × Liquidation Threshold) / Debt Value\n\nIf Health Factor < 1.0, position can be liquidated\n```\n\n### Example Calculation\n\n```\nPosition:\n- Collateral: 1000 conditional tokens @ $0.80 = $800\n- Debt: $500 USDC\n- Liquidation Threshold: 75%\n\nHealth Factor = ($800 × 0.75) / $500 = $600 / $500 = 1.2 ✓ Healthy\n\nIf token price drops to $0.65:\nHealth Factor = ($650 × 0.75) / $500 = $487.50 / $500 = 0.975 ❌ Liquidatable\n```\n\n## Liquidation Process\n\n### 1. Position Identification\n\nLiquidators monitor positions through:\n- On-chain health factor queries\n- Event logs for price updates\n- Mempool monitoring for arbitrage\n\n### 2. Liquidation Execution\n\n```solidity\nfunction liquidate(\n    address borrower,\n    uint256 positionId,\n    uint256 repayAmount\n) external {\n    // Verify position is liquidatable\n    require(healthFactor(borrower, positionId) < 1e18, \"Position healthy\");\n    \n    // Calculate collateral to seize\n    uint256 collateralPrice = oracle.getPrice(positionId);\n    uint256 liquidationBonus = getLiquidationBonus(positionId);\n    uint256 collateralToSeize = repayAmount * (1e18 + liquidationBonus) / collateralPrice;\n    \n    // Execute liquidation\n    usdc.transferFrom(msg.sender, address(this), repayAmount);\n    conditionalTokens.transfer(msg.sender, positionId, collateralToSeize);\n    \n    // Update borrower's position\n    positions[borrower][positionId].debt -= repayAmount;\n    positions[borrower][positionId].collateral -= collateralToSeize;\n}\n```\n\n### 3. Partial vs Full Liquidation\n\n**Partial Liquidation** (Preferred):\n- Liquidate up to 50% of the position\n- Brings health factor back above 1.0\n- Minimizes borrower losses\n\n**Full Liquidation**:\n- Only when partial isn't sufficient\n- Or position size is below minimum threshold\n\n## Liquidation Parameters\n\n### Base Parameters by Market Type\n\n| Market Type | Max LTV | Liquidation Threshold | Liquidation Bonus |\n|-------------|---------|----------------------|-------------------|\n| High Volume | 80% | 85% | 5% |\n| Medium Volume | 65% | 75% | 7.5% |\n| Low Volume | 50% | 60% | 10% |\n| Near Resolution | 30% | 40% | 15% |\n\n### Dynamic Adjustments\n\n**Volatility-Based Adjustment**:\n```\nAdjusted Bonus = Base Bonus × (1 + Volatility Score)\nVolatility Score = Recent Price Movement / Average Movement\n```\n\n**Time-Based Adjustment**:\n```\nNear Resolution Bonus = Base Bonus × (2 - Days to Resolution / 30)\n```\n\n## Liquidation Strategies\n\n### 1. Flash Loan Liquidation\n\n```solidity\ncontract FlashLiquidator {\n    function executeLiquidation(\n        address borrower,\n        uint256 positionId,\n        uint256 repayAmount\n    ) external {\n        // 1. Borrow USDC via flash loan\n        flashLoanProvider.borrow(repayAmount);\n        \n        // 2. Liquidate position\n        lendingPool.liquidate(borrower, positionId, repayAmount);\n        \n        // 3. Sell seized collateral\n        uint256 proceeds = dex.sell(conditionalTokens, collateralAmount);\n        \n        // 4. Repay flash loan\n        flashLoanProvider.repay(repayAmount + fee);\n        \n        // 5. Keep profit\n        profit = proceeds - repayAmount - fee;\n    }\n}\n```\n\n### 2. MEV-Protected Liquidation\n\nTo prevent frontrunning:\n- Commit-reveal scheme\n- Private mempool submission\n- Dutch auction for liquidation rights\n\n### 3. Keeper Network Integration\n\nAutomated liquidation bots:\n```javascript\nasync function monitorPositions() {\n    const positions = await lendingPool.getAllPositions();\n    \n    for (const position of positions) {\n        const healthFactor = await calculateHealthFactor(position);\n        \n        if (healthFactor < 1.0) {\n            const profit = estimateLiquidationProfit(position);\n            \n            if (profit > gassCost + minProfit) {\n                await executeLiquidation(position);\n            }\n        }\n    }\n}\n```\n\n## Price Oracle Considerations\n\n### Oracle Requirements\n\n1. **Accuracy**: Price within 2% of market\n2. **Freshness**: Updated within 5 minutes\n3. **Reliability**: Multiple price sources\n\n### Price Manipulation Protection\n\n```solidity\nfunction getSecurePrice(uint256 positionId) returns (uint256) {\n    uint256[] memory prices = new uint256[](3);\n    \n    prices[0] = polymarketOracle.getPrice(positionId);\n    prices[1] = chainlinkOracle.getPrice(positionId);\n    prices[2] = twapOracle.getPrice(positionId);\n    \n    // Use median price\n    return median(prices);\n}\n```\n\n### Circuit Breakers\n\n- Maximum price change per update: 10%\n- Pause liquidations on extreme volatility\n- Manual price override capability\n\n## Liquidation Incentives\n\n### For Liquidators\n\n1. **Base Liquidation Bonus**: 5-15% profit\n2. **Gas Rebates**: For maintaining protocol health\n3. **Priority Queue**: For consistent liquidators\n\n### For Borrowers\n\n1. **Grace Period**: 1-hour warning before liquidation\n2. **Partial Liquidation**: Minimize losses\n3. **Position Recovery**: Buy back liquidated collateral\n\n## Edge Cases and Solutions\n\n### 1. Bad Debt Scenario\n\nWhen collateral value < debt:\n```solidity\nif (collateralValue < debtValue) {\n    // Write off bad debt\n    badDebt[market] += debtValue - collateralValue;\n    \n    // Use insurance fund\n    if (insuranceFund >= badDebt[market]) {\n        insuranceFund -= badDebt[market];\n    }\n}\n```\n\n### 2. Cascading Liquidations\n\nPrevent death spirals:\n- Liquidation limits per block\n- Progressive liquidation bonuses\n- Emergency pause mechanism\n\n### 3. Oracle Failure\n\nFallback mechanisms:\n- Use last known good price\n- Increase liquidation threshold\n- Pause new borrows\n\n## Monitoring and Analytics\n\n### Key Metrics\n\n```sql\n-- Liquidation efficiency\nSELECT \n    DATE_TRUNC('day', timestamp) as day,\n    COUNT(*) as liquidation_count,\n    AVG(liquidation_bonus) as avg_bonus,\n    SUM(bad_debt) as total_bad_debt\nFROM liquidations\nGROUP BY day;\n\n-- At-risk positions\nSELECT \n    COUNT(*) as positions_at_risk,\n    SUM(debt_value) as total_debt_at_risk\nFROM positions\nWHERE health_factor < 1.1;\n```\n\n### Alert Thresholds\n\n- Health Factor < 1.1: Warning\n- Health Factor < 1.05: Critical\n- Bad debt > $10k: Emergency response\n\n## Future Improvements\n\n### 1. Progressive Liquidation\n\nInstead of fixed bonuses:\n```\nBonus = Base + (1 - Health Factor) × Multiplier\n```\n\n### 2. Social Liquidation\n\n- Community-funded liquidation pools\n- Shared liquidation profits\n- Decentralized keeper networks\n\n### 3. Self-Liquidation\n\nAllow borrowers to liquidate themselves:\n- No liquidation bonus required\n- Preserve more collateral\n- Better user experience\n\n## Best Practices\n\n### For Protocol Operators\n\n1. Regular parameter reviews\n2. Stress testing scenarios\n3. Insurance fund maintenance\n4. Liquidator ecosystem development\n\n### For Liquidators\n\n1. Efficient price monitoring\n2. Gas optimization\n3. Risk assessment tools\n4. Portfolio approach\n\n### For Borrowers\n\n1. Monitor health factors\n2. Maintain safety margins\n3. Set up alerts\n4. Have repayment plans\n\n## Conclusion\n\nA robust liquidation system is essential for:\n- Protocol solvency\n- Fair value discovery\n- Sustainable lending markets\n- User confidence

Effective liquidations protect both lenders and borrowers while maintaining market efficiency.
